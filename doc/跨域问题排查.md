# 跨域问题排查

## 问题背景

在网站 `blog.itbbs.com` 的文章页面中需要调用 `order.itbbs.com` 来进行创建确认订单，发生了跨域问题的错误，如下所示：

```
Access to fetch at 'http://order.itbbs.com/order/order/confirm' from origin 'http://blog.itbbs.com' has been blocked by CORS policy: Response to preflight request doesn't pass access control check: No 'Access-Control-Allow-Origin' header is present on the requested resource.
```

## 问题分析

笔者在 `blog.itbbs.com` 网站中也调用了 `system.itbbs.com` 获取用户信息，这是能够成功获取的。同理 `order.itbbs.com` 也应该能够请求成功啊，咋个没有？于是进行了探究，发现  `system.itbbs.com` 获取用户信息是走的 GET 请求

**触发跨域的条件是：**

- **若是简单请求（如：GET）不处理，否则复杂请求会先发送一个预检请求（OPTIONS）**
- **同HTTP协议、同域名、同端口**

所以获取用户信息（GET 请求）并没有触发跨域

为了解决复杂请求跨域问题，有两种方法，一种是 Nginx 配置，另一种是后端配置，笔者是统一在后端处理。请求首先会经过网关，再由网管转发到各个服务，经排查发现网关并没有引入公共服务模块，所以并没有做跨域配置，而其他服务引用了公共服务模块，就处理了跨域，所以只需要给网关配置上跨域就能可以了。网关中配置了如下代码

```java
@Configuration
public class GatewayCorsConfig {

    @Bean
    public CorsWebFilter corsWebFilter() {
        CorsConfiguration config = new CorsConfiguration();

        List<String> allowedOrigins = Arrays.asList(
                GatewayConstants.BLOG_SERVICE,
                GatewayConstants.ORDER_SERVICE,
                GatewayConstants.AUTH_SERVICE,
                GatewayConstants.SYSTEM_SERVICE,
                GatewayConstants.OSS_SERVICE,
                GatewayConstants.ROOT_SERVICE
        );

        // 使用 addAllowedOriginPattern 方法
        allowedOrigins.forEach(config::addAllowedOriginPattern);

        // 允许的方法
        config.setAllowedMethods(Arrays.asList(
                "GET", "POST", "PUT", "DELETE", "OPTIONS", "PATCH", "HEAD"
        ));

        // 允许的请求头
        config.setAllowedHeaders(Arrays.asList(
                "*"
        ));

        // 暴露的响应头
        config.setExposedHeaders(Arrays.asList(
                "Authorization",
                "Set-Cookie",
                "Access-Control-Allow-Origin",
                "Access-Control-Allow-Credentials"
        ));

        // 允许凭证
        config.setAllowCredentials(true);

        // 预检请求缓存时间
        config.setMaxAge(1800L);

        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser());
        source.registerCorsConfiguration("/**", config);

        return new CorsWebFilter(source);
    }
}
```

